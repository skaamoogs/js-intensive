Promise.resolve()
  .then(() => console.log("a: 1"))
  .then(() => {
    setTimeout(() => console.log("timeout 2"));
    console.log("a: 2");
  })
  .then(() => {
    setTimeout(() => console.log("timeout 3"));
    console.log("a: 3");
  });

new Promise((res, rej) => {
  console.log("b");
  rej(new Error("123"));
})
  .then(console.log("b 1"))
  .then(
    () => console.log("b 2"),
    () => console.log("b")
  )
  .catch(() => console.log("b 3"))
  .then(() => console.log("b 4"));

/** Тик 1
 * 1. Создается промис1 и тут же резолвится. В очередь микрозадач попадает функция console.log('a: 1').
 * 2. Создается промис2. Код внутри промиса выполняется синхронно
 * сразу же после создания промиса:
 *  - в консоль выводится "b".
 * 3. Внутри первого then второго промиса происходит проверка, что передана функция,
 * во время которой выполняется console.log:
 *  - в консоль выводится "b: 1",
 * происходит проваливание в следующий then, т.к. была передана не функция.
 * 4. Выполняются микрозадачи:
 *  - в консоль выводится 'a: 1'
 *
 * Тик 2
 * 5. В первом промисе в очередь микрозадач попадает setTimeout2 и console.log('a: 2')
 * 6. Во втором промисе в очередь микрозадач попадает второй callback: console.log('b'), т.к. предыдущий промис был отклонен.
 * 7. Выполняются микрозадачи:
 *    - запускается таймер с нулевой задержкой и в очередь макрозадач попадает console.log("timeout 2")
 *    - в консоль выводится 'a: 2'
 *    - в консоль выводится 'b'
 *
 * Тик 3
 * 8. В первом промисе в очередь микрозадач попадает setTimeout2 и console.log('a: 3')
 * 9. Во втором промисе в очередь микрозадач попадает console.log('b 4')
 * 10. Выполняются микрозадачи:
 *    - запускается таймер с нулевой задержкой и в очередь макрозадач попадает console.log("timeout 3")
 *    - в консоль выводится 'a: 3'
 *    - в консоль выводится 'b 4'
 * 11. Стек вызова и очередь микрозадач пуста,
 * поэтому выполняются макрозадачи:
 *    - в коносоль выводится "timeout 2",
 *    - в коносоль выводится "timeout 3"
 */
